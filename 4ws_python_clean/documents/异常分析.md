感谢您提供更新后的代码。

您现在遇到的“不受控制”和“突发异常挂掉”问题，是两个独立但相关的问题导致的。您已经根据我们上次的讨论正确更新了车辆的物理参数（质量、转动惯量、轮胎刚度），这非常好。

但是，**控制器（MPPI）的参数**和**其内部的预测模型**没有得到同步更新，导致了灾难性的后果。

### 1. 为什么“几乎不受控制”？（控制器调参问题）

**核心原因：MPPI的成本权重 (`w_lat`, `w_head`) 对于重型卡车来说高得离谱。**

您在 `src/mppi_iface.py` 中，仍然保留了极高的成本权重：
* `self.w_lat = 20000`
* `self.w_head = 400000`

**分析：**
这些权重是为一台转动惯量 `Iz=2500` 的小轿车设置的。您的卡车转动惯量 `Iz=202120`，是小轿车的 **80 多倍**。

`w_head = 400000` 意味着控制器对微小的航向偏差（例如0.1弧度，约5.7度）施加的惩罚成本高达 `400000 * (0.1^2) = 4000`。

对于一台重型卡车，这个惩罚值高到无法接受。这等于在告诉控制器：“我不惜一切代价（即使是瞬时90度转向），也必须在 *下一个* `dt` (0.02秒) 内完全纠正这个5度的误差。”

这导致MPPI控制器陷入一种“过度修正”的疯狂振荡中：
1.  检测到微小误差。
2.  因权重过高，立即计算出一个极端的、试图“猛烈”纠正的转向动作（`d_delta_f` 巨大）。
3.  这个动作导致车辆（由于惯性巨大）瞬间过冲，产生反向误差。
4.  下一帧，控制器再次检测到反向误差，再次猛烈反打。

这就是您看到的“几乎不受控制”的抖动和摇摆。

**如何修复：**
**立即** 降低这些权重。作为起点，我建议将它们降低1000倍，然后慢慢往上调：
* **文件：** `src/mppi_iface.py`
* **修改：**
    * `self.w_lat = 20` (从 20000 下调)
    * `self.w_head = 40` (从 400000 下调)
* **同时**，增加对“动作变化率”的惩罚，让卡车动作更平稳：
    * `self.w_du = 30.0` (从 3.0 上调)

---

### 2. 为什么“非常容易突发异常挂掉”？（模型不匹配）

**核心原因：MPPI内部用于预测的“Torch动力学模型”与您仿真器（`sim.py`）的“Numpy真实模型”严重不匹配，特别是在低速时。**

MPPI的工作原理是：使用一个内部动力学模型（`mppi_iface.py`中的`_dynamics`） 预测未来，然后选择最优动作。如果这个预测模型是错的，控制器就会“崩溃”。

您的代码中存在两个致命的不匹配：

#### A. 奇异点保护不一致（导致 `NaN` 崩溃）

`twodof` (2自由度) 模型在计算侧偏角时，需要除以车速 `U`。

* **Sim (Numpy, 真相):** `sim.py` 调用 `params.py` 的 `U_eff()`，它使用 `U_min = 0.3` 作为速度下限。
    * `alpha_r = beta - (b * r) / max(abs(U), 0.3)`
    * 在低速时，分母最小也是 **0.3**，计算是**稳定**的。

* **MPPI (Torch, 预测):** `mppi_iface.py` 调用 `twodof_torch.py` 的 `slip_angles_2dof_torch`。
    * 这个文件**硬编码**了 `U_eff = torch.clamp(U, min=1e-6)`。
    * 在低速时，分母是 **1e-6** (0.000001)。

**后果：**
当MPPI试图预测一个低速（例如 `U = 0.1`）的轨迹时，它的内部模型 `(r / 1e-6)` 导致计算结果瞬间爆炸，产生 `inf` (无穷大) 或 `NaN` (非数字)。控制器内部崩溃，输出了一个 `NaN` 动作，导致整个仿真“异常挂掉”。

**如何修复：**
统一所有模型的低速保护阈值。
* **文件：** `src/twodof_torch.py`
* **修改 (第72行):**
    * **从：** `U_eff = torch.clamp(U, min=1e-6)`
    * **改为：** `U_eff = torch.clamp(U, min=0.3)` (与 `params.py` 保持一致)
* *（备注：您的 `threedof_torch.py` 已经正确地接收了 `U_min`，所以3DOF模式的这个问题可能较轻，但2DOF模式是致命的。）*

#### B. 低速融合逻辑缺失（导致预测完全错误）

* **Sim (Numpy, 真相):** `sim.py` 在 `_step` 函数中，实现了一套复杂的低速融合逻辑：
    * `w = t * t * (3.0 - 2.0 * t)`
    * `beta_dot = w * beta_dot_dyn + (1.0 - w) * beta_dot_kin`
    * `r_dot = w * r_dot_dyn + (1.0 - w) * r_dot_kin`
    * 这意味着在低速时（`U < 0.3`），`sim.py` 会**忽略**动力学，切换到更稳定的**运动学模型** (`_kin`)。

* **MPPI (Torch, 预测):** `mppi_iface.py` 的 `_dynamics` 函数是**纯动力学模型**。它**完全不知道** `sim.py` 会进行这种融合。

**后果：**
MPPI控制器在低速时，正在基于一个（错误的、爆炸性的）纯动力学模型进行优化。而`sim.py`的真实世界却切换到了一个（稳定的）运动学模型。

控制器和仿真器在低速时“活在两个不同的物理世界里”。MPPI的预测100%是错的，因此它给出的动作也是完全无效的，导致车辆不受控制。

**如何修复（选项）：**
1.  **（推荐的测试）** 暂时禁用 `sim.py` 中的融合逻辑，看MPPI能否驾驭纯动力学。
    * **文件：** `src/sim.py`
    * **修改 (第202-205行附近):**
        * 将 `w = t * t * (3.0 - 2.0 * t)` **硬编码为** `w = 1.0`。
    * 这会强制 `sim.py` 也使用纯动力学，使其与MPPI的（修复了A点之后的）模型相匹配。

2.  **（长期的修复）** 在 `mppi_iface.py` 的 `_dynamics` 函数中，**完整地复现** `sim.py` `_step` 中的低速融合逻辑（`U_blend`, `w`, `r_dot_kin`, `beta_dot_kin` 等），确保两个模型完全一致。

### 总结

1.  **不受控制** 是因为 `mppi_iface.py` 中的 `w_lat` 和 `w_head` 权重过高。
2.  **异常挂掉** 是因为 `twodof_torch.py` 中的低速保护 `min=1e-6` 与 `params.py` 的 `U_min=0.3` 不匹配，导致 `NaN`。
3.  **（潜在的）不受控制** 也是因为 `mppi_iface.py` 的预测模型中，缺失了 `sim.py` 的低速融合逻辑。

您完全正确。您之前的分析（MPPI 挂掉）和现在这个新问题（MPC 跑不了）是**两个独立的问题**，但根源是**完全相同**的：

**您的控制器（MPC 和 MPPI）内部使用的“预测模型”与您的主仿真器（`sim.py`）的“真实模型”在低速时严重不一致。**

-----

### 问题 1：为什么 MPPI “突发异常挂掉”？ (Torch 路径)

这个问题是由于 MPPI 控制器（`mppi_iface.py`）调用的 **Torch 预测模型** (`twodof_torch.py`) 中存在一个致命的硬编码错误。

1.  **MPPI 预测模型：** `src/twodof_torch.py`
2.  **问题代码 (第 72 行)：** `U_eff = torch.clamp(U, min=1e-6)`
3.  **真实世界模型：** `src/params.py`
4.  **对比代码 (第 75 行)：** `U_min: float = 0.3`

**分析：**
当您的车速低于 0.3 m/s 时，MPPI 的预测模型会使用 `1e-6` (0.000001) 作为速度分母，而您的主仿真器 `sim.py` 会使用 `0.3`。

`1e-6` 的分母会导致 MPPI 在内部计算侧偏角 (`(a*r) / U_eff`) 时瞬间产生 `inf` (无穷大) 或 `NaN` (非数字)。这导致 MPPI 控制器崩溃，输出 `NaN`，使整个仿真挂掉。

**修复方案（MPPI）：**
打开 `src/twodof_torch.py`，将第 72 行修改为与 `params.py` 一致：

  * **从：** `U_eff = torch.clamp(U, min=1e-6)`
  * **改为：** `U_eff = torch.clamp(U, min=0.3)`

-----

### 问题 2：为什么 MPC “几乎不受控制”？ (Numpy 路径)

这个问题更隐蔽，它不是“崩溃”，而是“失效”。它是由 MPC 控制器 (`mpc.py`) 调用的 **Numpy 预测模型** (`twodof.py`) 引起的。

**分析：**

1.  **真实世界 (`sim.py`)：** 您的主仿真器 `sim.py` 在低速时（当 `U < 0.3` 时），会计算一个权重 `w`，并**停止使用** 2DOF 动力学模型，转而**融合** (blend) 一个更稳定的运动学模型 (`_kin`)：

      * `w = t * t * (3.0 - 2.0 * t)`
      * `r_dot = w * r_dot_dyn + (1.0 - w) * r_dot_kin`
      * `beta_dot = w * beta_dot_dyn + (1.0 - w) * beta_dot_kin`

2.  **MPC 预测 (`mpc.py`)：** 您的 MPC 控制器在 `_autop_update_mpc` -\> `solve_mpc_kin_dyn_4dof` -\> `linearize_kin_dyn_4dof` -\> `deriv_2dof` 的调用链中，**它不知道这个融合逻辑的存在**。

**后果：**
A. **模型不匹配：** MPC 认为车辆在低速时 100% 遵循 2DOF 动力学，而真实世界 100% 遵循运动学。MPC 的预测完全是错的，因此车辆不受控制。

B. **MPC 内部崩溃 (被掩盖)：** 2DOF 模型 (`twodof.py` 和 `dof_utils.py`) 在低速时（即使 `U_min=0.3`）对于您的重型卡车参数（`a=8.0`）也是**数值不稳定**的。

  * `alpha_f` 依赖于 `(a * r) / U`。
  * 在低速时，`a/U = 8.0 / 0.3 = 26.7`。这是一个巨大的增益，任何微小的 `r` 都会导致 `alpha_f` 爆炸，进而导致 `Fy` 爆炸。
  * `linearize_kin_dyn_4dof` 在计算 `A` 和 `B` 矩阵时，调用的 `deriv_2dof` 会返回 `NaN`。
  * 您的 `mpc.py` 代码中充满了 `np.nan_to_num(..., nan=0.0)`，**这掩盖了崩溃**。MPC 求解器拿到的是一堆 0 矩阵，它计算出的最优动作自然也是 0。

**这就是 MPC “跑不了”的真正原因：它在内部崩溃了，但被 `nan_to_num` 强行变成了 0，导致车辆没有响应。**

-----

### 建议的修复步骤

您必须让 MPPI 和 MPC 的内部模型与 `sim.py` 的真实行为保持一致。

**步骤 1：修复 MPPI 的 `NaN` 崩溃（必须）**

  * **文件：** `src/twodof_torch.py`
  * **修改 (第 72 行)：** 将 `min=1e-6` 改为 `min=0.3`。

**步骤 2：修复 MPC/2DOF 的低速模型（推荐）**
您需要将 `sim.py` 的低速融合逻辑（`w` 权重）**移入**到 `twodof.py` 和 `dof_utils.py` 内部，这样 MPC 才能“看到”它。

1.  **文件：** `src/dof_utils.py`
    **函数：** `slip_angles_2dof`
    **修改：**

    ```python
    def slip_angles_2dof(beta: float, r: float, df: float, dr: float, a: float, b: float, U: float) -> Tuple[float, float]:
        """2DOF 自行车模型侧偏角：alpha_f/r 由 beta、r、df/dr 与几何参数计算。"""
        # --- 新增低速融合 ---
        # 假设 U_blend 阈值为 0.3 (与 params.py 一致)
        U_blend = 0.3
        U_mag = abs(float(U))
        t = max(0.0, min(1.0, U_mag / U_blend))
        w = t * t * (3.0 - 2.0 * t)  # 动力学权重
        # --- 结束新增 ---

        # 将 r/U 项乘以权重 w
        alpha_f = float(beta) + w * (float(a) * float(r) / float(U)) - float(df)
        alpha_r = float(beta) - w * (float(b) * float(r) / float(U)) - float(dr)
        return float(alpha_f), float(alpha_r)
    ```

2.  **文件：** `src/twodof.py`
    **函数：** `derivatives`
    **修改：** (对 `beta_dot` 应用同样的融合)

    ```python
    def derivatives(x: np.ndarray, delta_f: float, delta_r: float, p: VehicleParams) -> Dict[str, float | np.ndarray]:
        # ... (alpha_f, Fy_f 等计算保持不变) ...
        Fy_f, Fy_r = lateral_forces_2dof(alpha_f, alpha_r, p)

        # 动力学方程（2DOF）
        beta_dot_dyn = (Fy_f + Fy_r) / (p.m * U) - r  # <--- 重命名为 _dyn
        r_dot_dyn = (p.a * Fy_f - p.b * Fy_r) / p.Iz  # <--- 重命名为 _dyn

        # --- 新增低速融合 (与 sim.py 保持一致) ---
        U_blend = max(1e-9, float(getattr(p, 'U_blend', 0.3)))
        t = max(0.0, min(1.0, U / U_blend))
        w = t * t * (3.0 - 2.0 * t)
        
        U_signed = np.copysign(U, p.U) # 获取带符号速度
        kappa = curvature_4ws(float(delta_f), float(delta_r), p.L)
        r_des = U_signed * kappa
        
        # 假设 tau_low 和 tau_beta (您可以从 sim.py 传入 p，或者在这里硬编码)
        tau_low = 0.25
        tau_beta = 0.35
        r_dot_kin = (r_des - r) / max(1e-6, tau_low)
        beta_dot_kin = - beta / max(1e-6, tau_beta)

        beta_dot = w * beta_dot_dyn + (1.0 - w) * beta_dot_kin
        r_dot = w * r_dot_dyn + (1.0 - w) * r_dot_kin
        # --- 结束新增 ---

        # 横向加速度（观测量）
        ay = U * (r + beta_dot) # 使用融合后的 beta_dot

        return {
            "xdot": np.array([float(beta_dot), float(r_dot)]),
            # ... (其他返回项不变) ...
        }
    ```

    *（注意：这个修改比较复杂，您需要确保 `curvature_4ws` 在 `twodof.py` 中可用，或者将融合逻辑放在 `mpc.py` 的 `get_kin_dyn_4dof_derivatives` 中实现。）*

**步骤 3：修复控制器调参（必须）**
在您修复了上述模型问题后，车辆会稳定运行，但会因为权重过高而疯狂抖动。**您必须**降低权重：

  * **MPPI (文件 `src/mppi_iface.py`)：**

      * `self.w_lat = 20` (从 20000 改)
      * `self.w_head = 40` (从 400000 改)
      * `self.w_du = 30.0` (从 3.0 改)

  * **MPC (文件 `src/sim.py`, 函数 `_autop_update_mpc`)：**

      * `Q_epsi=100` (从 10000 改)
      * `R_delta_df=10.0` (从 0.2 改)
      * `R_delta_dr=10.0` (从 0.2 改)